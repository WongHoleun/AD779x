/**
  ******************************************************************************
  * 模块名称：软件算法模块
  * 文件名	：ALGORITHM.c
  * 说明	：c文件，提供用户自定义数据类型、宏和变量以及供外部调用的接口函数的实现
  * 版本号	：个人版
  * 修改记录：算法参考 https://acuity.blog.csdn.net/article/details/114808763
  ******************************************************************************
  */

#include "ALGORITHM.h"
#include "stdio.h"

/* PT1000 阻值-温度表：20.0~39.9 步进0.1℃ */
const float PT1000_CODE[] = 
{
	1077.935,	1078.324,	1078.712,	1079.101,	1079.489,	1079.877,	1080.266,	1080.654,	1081.043,	1081.431,	//20.0~20.9
	1081.820,	1082.208,	1082.596,	1082.985,	1083.373,	1083.762,	1084.150,	1084.538,	1084.926,	1085.315,	//21.0~21.9
	1085.703,	1086.091,	1086.480,	1086.868,	1087.256,	1087.644,	1088.033,	1088.421,	1088.809,	1089.197,	//22.0~22.9
	1089.585,	1089.974,	1090.362,	1090.750,	1091.138,	1091.526,	1091.914,	1092.302,	1092.690,	1093.078,	//23.0~23.9
	1093.467,	1093.855,	1094.243,	1094.631,	1095.019,	1095.407,	1095.795,	1096.183,	1096.571,	1096.959,	//24.0~24.9
	1097.347,	1097.734,	1098.122,	1098.510,	1098.898,	1099.286,	1099.674,	1100.062,	1100.450,	1100.838,	//25.0~25.9
	1101.225,	1101.613,	1102.001,	1102.389,	1102.777,	1103.164,	1103.552,	1103.940,	1104.328,	1104.715,	//26.0~26.9
	1105.103,	1105.491,	1105.879,	1106.266,	1106.654,	1107.042,	1107.429,	1107.817,	1108.204,	1108.592,	//27.0~27.9
	1108.980,	1109.367,	1109.755,	1110.142,	1110.530,	1110.917,	11110305,	1111.693,	1112.080,	1112.468,	//28.0~28.9
	1112.855,	1113.242,	1113.630,	1114.017,	1114.405,	1114.792,	1115.180,	1115.567,	1115.954,	1116.342,	//29.0~29.9
	1116.729,	1117.117,	1117.504,	1117.891,	1118.279,	1118.666,	1119.053,	1119.441,	1119.828,	1120.215,	//30.0~30.9
	1120.602,	1120.990,	1121.377,	1121.764,	1122.151,	1122.538,	1122.926,	1123.313,	1123.700,	1124.087,	//31.0~31.9
	1124.474,	1124.861,	1125.248,	1125.636,	1126.023,	1126.410,	1126.797,	1127.184,	1127.571,	1127.958,	//32.0~32.9
	1128.345,	1128.732,	1129.119,	1130.127,	1129.893,	1130.280,	1130.667,	1131.054,	1131.441,	1131.828,	//33.0~33.9
	1132.215,	1132.602,	1132.988,	1133.375,	1133.762,	1134.149,	1134.536,	1134.923,	1135.309,	1135.696,	//34.0~34.9
	1136.083,	1136.470,	1136.857,	1137.243,	1137.630,	1138.017,	1138.404,	1138.790,	1139.177,	1139.564,	//35.0~35.9
	1139.950,	1140.337,	1140.724,	1141.110,	1141.497,	1141.884,	1142.270,	1142.657,	1143.043,	1143.430,	//36.0~36.9
	1143.817,	1144.203,	1144.590,	1144.976,	1145.363,	1145.749,	1146.136,	1146.522,	1146.909,	1147.295,	//37.0~37.9
	1147.681,	1148.068,	1148.454,	1148.841,	1149.227,	1149.614,	1150.000,	1150.386,	1150.773,	1151.159,	//38.0~38.9
	1151.545,	1151.932,	1152.318,	1152.704,	1153.091,	1153.477,	1153.863,	1154.249,	1154.636,	1155.022,	//39.0~39.9
};

/**
  * 函数名称：binary_search
  * 函数功能：二分法查找
  * 入口参数：
  *  					buf	:	待查找数据表
  *				buf_size	:	表格大小
  * 			s_value	:	查找目标值
  * 返回值	：有对应匹配的阻值大小返回0，否则返回1
  * 注意事项：若目标值在数据表中无匹配值，则返回最小区间的左值
  */
uint8_t binary_search(const float *buf, uint32_t buf_size, float s_value, uint32_t *out_data)
{
	uint32_t index_bottom = 0;
	uint32_t index_top = buf_size - 1;
	uint32_t index_mid = buf_size / 2 - 1;

	while (index_top - index_bottom > 1)
	{
		if (s_value < buf[index_mid])
		{
			index_top=index_mid;	
		}
		else if(s_value > buf[index_mid])
		{
			index_bottom = index_mid;	
		}
		else
		{
			*out_data = index_mid;  			// 恰好中值
            return 0x00;
		}
		index_mid=(index_bottom + index_top) / 2;
	}
	
	*out_data = index_bottom;   				// 处于区间内，返回左值
    
	return 0x01;
}

/**
  * 函数名称：resi_temp_calc
  * 函数功能：插值法阻值-温度换算
  * 入口参数：resi	:	电阻阻值
  * 返回值	：实际温度值(℃)
  * 注意事项：X表示阻值，Y表示温度，用Value代表数组某一元素
  */
float resi_temp_calc(float resi)
{
    int8_t ret = 0;
    uint32_t value = 0;
    float temp = 0.0f;
    float x1 = 0.0f;
    float x2 = 0.0f;
    float y1 = 0.0f;
    float y2 = 0.0f;

    ret = binary_search(&PT1000_CODE[0], sizeof(PT1000_CODE)/sizeof(float), resi, &value);
    
    if (0x00 == ret)
    {
        temp = value * 0.1f + 20;
    }

	/* 插值法计算 */
    else
    {
        x1 = PT1000_CODE[value];	
        y1 = value;
        x2 = PT1000_CODE[value + 1];
        y2 = value + 1;
        temp = (y1 * (resi - x2) / (x1 - x2) + y2 * (resi - x1) / (x2 - x1)) * 0.1f + 20;
    }
    return temp;
}

